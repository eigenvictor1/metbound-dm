#include"micromegas.h"
#include"micromegas_aux.h"
#include"micromegas_f.h"

int SpectraFlag=0;

int useBoost=0;

double Zi(int i) { return log(1.E-7)*pow((double)(i-1)/250.,1.5) ;}
static  int Iz(double z) { if(z>0) return 0;  return 250*pow(z/log(1.E-7),1./1.5)+1; }

double SpectdNdE(double E,  void*arg)
{
  double *tab=arg;
  double z;
  if(E<1E-10) E=1.E-10;
  if(E>tab[0]) return 0;
  z=log(E/tab[0]);
   
  double res= 1/E*zInterp(z,tab);
     
  return res;
}

double eSpectdNdE(double E,  void * arg)
{
  double *tab=arg;
  double z;
  if(E>tab[0]) return 0;
  z=log(E/tab[0]); 
  return  zInterp(z,tab); 
}

void  fillSpect(double (*dNdE)(double ), double Emax, double * SpectAr)
{ int i;
  SpectAr[0]=Emax;
  for(i=1;i<NZ;i++) 
  { double E=exp(Zi(i))*Emax;  
    SpectAr[i]=dNdE(E)*E;
  }
}

double zInterp(double zz, double  * tab) 
{  

   double dz,r;
   int j0;   
   if(zz>0) return 0;
   
   j0=Iz(zz); 
   if(j0<1) j0=1;
   if(j0>=NZ-1) return  0; // tab[NZ-1];
   
   dz= (zz-Zi(j0))/(Zi(j0+1)-Zi(j0));
   r=(1-dz)*tab[j0]+dz*tab[j0+1];
   if(r<0)r=0;
   return r; 
}

static double zInterpVoid(double zz, void * tabVoid) { double *tab=(double*)tabVoid; return zInterp(zz, tab);}  

double xInterp(double x, double*tab) { return zInterp(log(x),tab);}

static double zInterpE(double x, void *tabVoid )
{ 
  double *tab=(double *) tabVoid;
  return    zInterp(x,tab)*exp(x);
}  





#define NEn 36  /* Number of Energy points for interpolation */
#define Nin 16 
#define Nout 7

static float phidiff[Nin][Nout][NEn][250];

static int readSpectra(void)
{ static int rdOk=0;
  int k,l,i,n;
  FILE *f;
  char * buff;
  char *fnames[Nin]={"gg.dat","dd.dat","uu.dat","ss.dat","cc.dat",
                     "bb.dat","tt.dat","ee.dat","mm.dat","ll.dat",
                     "zz.dat","zz_t.dat","zz_l.dat",
                     "ww.dat","ww_t.dat","ww_l.dat"};
  if(rdOk) return 0;
  
  buff=malloc(strlen(micrO)+100);

  for(n=0;n<Nin;n++)
  {  sprintf(buff,"%s/Data/Pythia6/%s",micrO,fnames[n]);
     f=  fopen(buff,"r");
     if(f==NULL) { free(buff);return 1;}    
     for(i=0;i<6;i++)
     { char ppp[20];
       fscanf(f,"%s",ppp);
       for(k=0;k<NEn;k++)
       {
         for(l=0;l<250;l++) if(1!=fscanf(f,"%f",phidiff[n][i][k]+l)) break;
         fscanf(f,"%*s"); 
         for(;l<250;l++)phidiff[n][i][k][l]=0;
       }
     }
     fclose(f);
  }
     
  free(buff);
  rdOk=1;   
  return 0;
}



//char *fnames[Nin]={"gg.dat","dd.dat","uu.dat","ss.dat","cc.dat","bb.dat","tt.dat","ee.dat","mm.dat","ll.dat","zz.dat","zz_t.dat","zz_l.dat","ww.dat","ww_t.dat","ww_l.dat"};
//                      0        1        2        3        4        5        6        7        8        9        10         11         12       13         14         15

static void mInterp(double Nmass,  int  CHin,int  CHout, double*tab)
{  
   double mi[NEn]={0.105,0.14,0.3,0.5,0.6,0.9,1.3,1.8, 2 ,5 ,10,25,50,80.3,85,91.2,92,95,100,110,120,125,130,140,150,176,200,250,350,500,750,1000,1500,2000,3000,5000};
//                  0     1    2   3   4   5   6   7   8  9  10 11 12   13 14  15  16 17  18  19  20  21  22  23  24  25
   int l,i0;
   double c0,c1;
   float *p0,*p1;
   for(i0=0; i0<NEn && Nmass>=mi[i0] ;i0++);
   if(i0) i0--;

   int i00=-1;
   switch(CHin)  /* below pole mass and/or below end of table */
   { 
     case  0:                      if(i0<4)  i00=4;  break; /* g */ 
     case 1: case 2:               if(i0<4)  i00=4;  break; /* d, u */             
     case 3:                       if(i0<4)  i00=4;  break; /* s */
//     case 4: 
     case 7:
                                   if(i0<8)  i00=8;  break; /* c  M=2  */
     case  9:                      if(i0<7)  i00=7;  break; /* for l      M=1.5*/      
     case  6:                      if(i0<25) i00=25; break; /* t m<17          */
     case 13: case 14: case 15:    if(i0<14) i00=14; break; /* W m<80.3        */
     case 10: case 11: case 12:    if(i0<15) i00=15; break; /* Z m<91.2        */
   } 

   if(i00>=0) 
   {  tab[0]=Nmass;
      if(CHin >= 10 && CHin<=15) 
      { for(l=1;l<250;l++) tab[l]=phidiff[CHin][CHout][i00][l-1]; 
         
        if(CHout==2 || CHout==6) 
        {  double C=0;
           double Mout=0.938;
           if(Nmass>Mout)  C=  (Nmass-Mout)/(mi[i00]-Mout);  //* (mi[i00]+2*Mout)/(Nmass+2*Mout);     //C=(decayPcm(2*Nmass,Mout,Mout)/Nmass)/ (decayPcm(2*mi[i00],Mout,Mout)/mi[i00]);
           for(l=1;l<250;l++) tab[l]*=C;
        }
      } 
      else for(l=1;l<250;l++) tab[l]=0; 
      return;
   }
   p0=phidiff[CHin][CHout][i0];
   p1=phidiff[CHin][CHout][i0+1];
   if(i0==NEn-1 || (Nmass<=2 && CHin >100) ) for(l=1;l<250;l++) tab[l]= p0[l-1];
   else
   {
//      c1=(Nmass*Nmass -mi[i0]*mi[i0])/(mi[i0+1]*mi[i0+1] - mi[i0]*mi[i0]);
//      c1=(Nmass - mi[i0])/(mi[i0+1] - mi[i0]);
     c1=(log(Nmass)-log(mi[i0]))/(log(mi[i0+1])-log(mi[i0]));
     c0=1-c1;
// printf("i0=%d i0+1=%d mi[i0]=%E mi[i0+1]=%E c1=%e c0=%e\n",i0,i0+1, mi[i0],mi[i0+1],c1,c0);     
     for(l=1;l<250;l++) tab[l]= c0*p0[l-1]+c1*p1[l-1];
   }
   tab[0]=Nmass;
}


static double outMass[Nout]= {0.,0.511E-3,0.939,0.,0.,0.,1.875};
char* outNames[Nout]={"gamma","e+","p-","nu_e","nu_mu","nu_tau","D"};

  // delta(1-x)
  
#define   D1 (2/(-Zi(3)))
#define   D2 (2/(-Zi(3))*( 1-Zi(2)/Zi(3)))

#define Me (5E-4)
#define Mm (0.105)
 
static double muonRestE(double E)  // 1907.11846 Eq.6.2
{ E+=Me; 
  if(E>Mm/2) return 0;
  double x=2*E/Mm;
  double r=Me/Mm;
  double res= - 4*sqrt(x*x-4*r*r)*(r*r*(4-3*x)+x*(2*x-3))/Mm;
  if(!isfinite(res))  return 0;
  return res;
}

static double muonRestA(double E)  // 1907.11846 Eq.4.21
{ 
  if(E>Mm/2) return 0;
  double x=2*E/Mm;
  double r=(Me/Mm)*(Me/Mm);
  double al=1./137.;
  double res=  al*(1-x)/(36*M_PI*E)*( 12*(3-2*x*pow(1-x,2))*log((1-x)/r) 
                      +x*(1-x)*(46-55*x) -102 );
  if(!isfinite(res))  return 0;
  return res;
}




static int basicSpectraS(double Mass, int pdgN, int outN, double * tab)
{ 
//  printf("basicSpectra: pdg=%d outN=%d\n", pdgN, outN);
  tab[0]=Mass;
  for(int i=1;i<NZ;i++) tab[i]=0;
  if(outN<0 ||  outN>5  ) return 1;
//  if(Mass<2) return 3;
  int N=abs(pdgN);
  
  switch(N) //  delta-like spectra 
  {
    case 22: if(outN==0){ tab[1]=2*D1; tab[2]=2*D2; } return 0;  
    case 12:
    case 14:
    case 16: if(2*outN==N-6) { tab[1]+=D1; tab[2]+=D2; } return 0;
  }

  if(N==111) 
  { double mpi=0.1349768;
    if(outN!=0 || Mass<mpi) return 0;
    double xi=mpi/Mass;
    double x1=0.5*(1-sqrt(1-xi*xi)), x2=0.5*(1+sqrt(1-xi*xi));
    int i1=Iz(log(x1)),i2=Iz(log(x2));
    if(i2<1) i2=1; 
    if(i1>NZ-1) i1=NZ-1;
    double f=(exp(Zi(i2))-exp(Zi(i1)));
    if(i2>1) f+=0.5*(exp(Zi(i2-1))-exp(Zi(i2)));
    if(i1<NZ-1) f+= 0.5*(exp(Zi(i1))-exp(Zi(i1+1)));
    f=4/f;  
    
    for(int i=i2;i<=i1;i++) { double x=exp(Zi(i));  tab[i]=x*f;}
    return 0;
  }
  if(N==11)
  {  if(outN==1) { tab[1]+=D1; tab[2]+=D2; } else
     if(outN==0) for(int i=1;i<NZ;i++) 
     { double me=0.511E-3, E=Mass*exp(Zi(i));  
       tab[i]=E*FSRdNdE(E,sqrt(Mass*Mass-me*me),me, 1, 1,0);
     }
     return 0;
  }
           
  double mX=-1,qX=0;     

  switch(N)  
  {  
     case 13: mX=0.10566; qX=1; if(mX>=Mass || outN>1) return 0;
              if(outN==0) { fillSpect(muonRestA,mX/2,tab); for(int i=1;i<NZ;i++) tab[i]*=2;}
              if(outN==1)   fillSpect(muonRestE,mX/2,tab);  
              break;
     case 211 :
     {  mX=0.13957,qX=1;
       if(mX>=Mass || outN > 1) return 0;
       double SPA[249]={0.000e+00,9.888e-06,1.306e-05,1.762e-05,2.564e-05,3.887e-05,5.903e-05,8.808e-05,1.265e-04,1.767e-04,2.396e-04,3.184e-04,4.092e-04,5.188e-04,6.430e-04,7.863e-04,9.472e-04,1.130e-03,1.325e-03,1.544e-03,1.780e-03,2.032e-03,2.310e-03,2.599e-03,2.912e-03,3.240e-03,3.585e-03,3.942e-03,4.300e-03,4.654e-03,5.004e-03,5.349e-03,5.688e-03,6.021e-03,6.347e-03,6.667e-03,6.981e-03,7.298e-03,7.617e-03,7.935e-03,8.251e-03,8.563e-03,8.873e-03,9.178e-03,9.478e-03,9.775e-03,1.007e-02,1.035e-02,1.064e-02,1.092e-02,1.119e-02,1.146e-02,1.173e-02,1.200e-02,1.226e-02,1.251e-02,1.276e-02,1.301e-02,1.325e-02,1.349e-02,1.373e-02,1.396e-02,1.419e-02,1.441e-02,1.463e-02,1.484e-02,1.504e-02,1.525e-02,1.545e-02,1.564e-02,1.582e-02,1.601e-02,1.618e-02,1.635e-02,1.652e-02,1.668e-02,1.684e-02,1.699e-02,1.713e-02,1.727e-02,1.741e-02,1.754e-02,1.766e-02,1.778e-02,1.790e-02,1.801e-02,1.812e-02,1.822e-02,1.832e-02,1.841e-02,1.850e-02,1.858e-02,1.866e-02,1.874e-02,1.882e-02,1.889e-02,1.895e-02,1.902e-02,1.908e-02,1.913e-02,1.919e-02,1.924e-02,1.929e-02,1.934e-02,1.938e-02,1.942e-02,1.946e-02,1.950e-02,1.954e-02,1.957e-02,1.960e-02,1.963e-02,1.966e-02,1.968e-02,1.971e-02,1.973e-02,1.976e-02,1.978e-02,1.980e-02,1.981e-02,1.983e-02,1.985e-02,1.986e-02,1.988e-02,1.989e-02,1.991e-02,1.992e-02,1.993e-02,1.994e-02,1.995e-02,1.996e-02,1.997e-02,1.997e-02,1.998e-02,1.999e-02,2.000e-02,2.000e-02,2.001e-02,2.001e-02,2.002e-02,2.002e-02,2.003e-02,2.003e-02,2.004e-02,2.004e-02,2.004e-02,2.005e-02,2.005e-02,2.005e-02,2.005e-02,2.006e-02,2.006e-02,2.006e-02,2.006e-02,2.006e-02,2.007e-02,2.007e-02,2.007e-02,2.007e-02,2.007e-02,2.007e-02,2.007e-02,2.007e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.008e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02,2.009e-02};
       double SPE[249]={0.000E+00,0.000E+00,2.029E-02,6.492E-02,1.166E-01,1.737E-01,2.349E-01,2.991E-01,3.655E-01,4.330E-01,5.010E-01,5.688E-01,6.356E-01,7.010E-01,7.643E-01,8.252E-01,8.831E-01,9.377E-01,9.888E-01,1.036E+00,1.079E+00,1.118E+00,1.153E+00,1.183E+00,1.209E+00,1.231E+00,1.248E+00,1.215E+00,1.143E+00,1.072E+00,1.002E+00,9.340E-01,8.679E-01,8.041E-01,7.430E-01,6.846E-01,6.292E-01,5.768E-01,5.275E-01,4.812E-01,4.380E-01,3.978E-01,3.605E-01,3.259E-01,2.941E-01,2.649E-01,2.380E-01,2.135E-01,1.912E-01,1.709E-01,1.525E-01,1.358E-01,1.207E-01,1.072E-01,9.498E-02,8.404E-02,7.425E-02,6.551E-02,5.771E-02,5.077E-02,4.460E-02,3.913E-02,3.429E-02,3.001E-02,2.623E-02,2.290E-02,1.997E-02,1.740E-02,1.514E-02,1.316E-02,1.143E-02,9.916E-03,8.595E-03,7.444E-03,6.442E-03,5.570E-03,4.812E-03,4.155E-03,3.585E-03,3.091E-03,2.664E-03,2.294E-03,1.975E-03,1.700E-03,1.462E-03,1.257E-03,1.080E-03,9.284E-04,7.976E-04,6.852E-04,5.885E-04,5.054E-04,4.341E-04,3.728E-04,3.202E-04,2.751E-04,2.364E-04,2.031E-04,1.746E-04,1.502E-04,1.292E-04,1.112E-04,9.574E-05,8.249E-05,7.110E-05,6.133E-05,5.294E-05,4.572E-05,3.952E-05,3.418E-05,2.959E-05,2.564E-05,2.223E-05,1.929E-05,1.676E-05,1.457E-05,1.268E-05,1.104E-05,9.623E-06,8.397E-06,7.333E-06,6.410E-06,5.608E-06,4.911E-06,4.305E-06,3.776E-06,3.315E-06,2.913E-06,2.561E-06,2.254E-06,1.985E-06,1.749E-06,1.543E-06,1.361E-06,1.202E-06,1.062E-06,9.389E-07,8.303E-07,7.347E-07,6.504E-07,5.760E-07,5.103E-07,4.522E-07,4.009E-07,3.555E-07,3.153E-07,2.797E-07,2.482E-07,2.203E-07,1.955E-07,1.735E-07,1.541E-07,1.368E-07,1.214E-07,1.078E-07,9.570E-08,8.496E-08,7.542E-08,6.694E-08,5.942E-08,5.273E-08,4.679E-08,4.152E-08,3.683E-08,3.267E-08,2.897E-08,2.569E-08,2.277E-08,2.018E-08,1.788E-08,1.584E-08,1.403E-08,1.243E-08,1.100E-08,9.737E-09,8.616E-09,7.621E-09,6.740E-09,5.959E-09,5.267E-09,4.655E-09,4.112E-09,3.631E-09,3.206E-09,2.830E-09,2.497E-09,2.203E-09,1.942E-09,1.712E-09,1.509E-09,1.330E-09,1.171E-09,1.031E-09,9.076E-10,7.987E-10,7.026E-10,6.179E-10,5.432E-10,4.774E-10,4.194E-10,3.684E-10,3.235E-10,2.839E-10,2.492E-10,2.186E-10,1.917E-10,1.680E-10,1.473E-10,1.290E-10,1.130E-10,9.895E-11,8.661E-11,7.579E-11,6.630E-11,5.798E-11,5.069E-11,4.430E-11,3.870E-11,3.380E-11,2.952E-11,2.576E-11,2.248E-11,1.961E-11,1.710E-11,1.491E-11,1.300E-11,1.132E-11,9.863E-12,8.588E-12,7.476E-12,6.506E-12,5.660E-12,4.922E-12,4.280E-12,3.720E-12,3.232E-12,2.808E-12,2.438E-12,2.117E-12,1.837E-12,1.594E-12,1.383E-12,1.199E-12,1.039E-12,9.006E-13,7.802E-13,6.757E-13,5.851E-13,5.065E-13};

       if(outN==0) for(int i=1;i<250;i++) tab[i]=2*SPA[i-1];
          else     for(int i=1;i<250;i++) tab[i]= SPE[i-1];  
       tab[0]=mX/2;

     }  break;
     case 321:  // K+/-
     {  mX=0.49368,qX=1;
       if(mX>=Mass || outN > 1) return 0;
       double SPA[249]={0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,4.471E-01,4.479E-01,4.487E-01,4.494E-01,4.497E-01,4.495E-01,4.488E-01,4.474E-01,4.453E-01,4.425E-01,4.390E-01,4.347E-01,4.298E-01,4.242E-01,4.180E-01,4.112E-01,4.050E-01,3.998E-01,3.953E-01,3.913E-01,3.879E-01,3.848E-01,3.819E-01,3.791E-01,3.762E-01,3.732E-01,3.699E-01,3.661E-01,3.619E-01,3.570E-01,3.516E-01,3.453E-01,3.384E-01,3.307E-01,3.223E-01,3.129E-01,3.010E-01,2.895E-01,2.793E-01,2.684E-01,2.579E-01,2.469E-01,2.345E-01,2.219E-01,2.092E-01,1.966E-01,1.843E-01,1.724E-01,1.608E-01,1.497E-01,1.392E-01,1.296E-01,1.208E-01,1.127E-01,1.054E-01,9.895E-02,9.334E-02,8.860E-02,8.401E-02,7.937E-02,7.469E-02,6.990E-02,6.510E-02,6.032E-02,5.611E-02,1.481E-02,1.583E-02,1.663E-02,1.724E-02,1.769E-02,1.799E-02,1.816E-02,1.822E-02,1.819E-02,1.807E-02,1.788E-02,1.763E-02,1.732E-02,1.749E-02,1.764E-02,1.790E-02,1.802E-02,1.827E-02,1.841E-02,1.861E-02,1.879E-02,1.884E-02,1.913E-02,1.926E-02,1.927E-02,1.958E-02,1.975E-02,1.977E-02,1.985E-02,2.019E-02,2.036E-02,2.037E-02,2.025E-02,2.058E-02,2.100E-02,2.121E-02,2.125E-02,2.113E-02,2.090E-02,2.106E-02,2.207E-02,2.276E-02,2.317E-02,2.335E-02,2.334E-02,2.315E-02,2.284E-02,2.241E-02,2.190E-02,2.132E-02,2.123E-02,2.127E-02,2.130E-02,2.133E-02,2.137E-02,2.139E-02,2.142E-02,2.145E-02,2.146E-02,2.150E-02,2.150E-02,2.151E-02,2.153E-02,2.155E-02,2.157E-02,2.158E-02,2.159E-02,2.161E-02,2.162E-02,2.163E-02,2.164E-02,2.166E-02,2.166E-02,2.168E-02,2.168E-02,2.168E-02,2.170E-02,2.171E-02,2.172E-02,2.172E-02,2.171E-02,2.174E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02,2.177E-02};
       double SPE[249]={0.000E+00,2.713E-03,1.249E-02,2.494E-02,3.934E-02,5.525E-02,7.229E-02,9.017E-02,1.100E-01,1.334E-01,1.593E-01,1.863E-01,2.137E-01,2.409E-01,2.675E-01,2.931E-01,3.175E-01,3.406E-01,3.624E-01,3.826E-01,4.013E-01,4.185E-01,4.341E-01,4.483E-01,4.610E-01,4.723E-01,4.822E-01,4.907E-01,4.982E-01,5.041E-01,5.085E-01,5.113E-01,5.123E-01,5.117E-01,5.097E-01,5.067E-01,5.030E-01,4.982E-01,4.922E-01,4.852E-01,4.773E-01,4.689E-01,4.597E-01,4.653E-01,4.780E-01,4.884E-01,4.964E-01,5.019E-01,5.053E-01,5.066E-01,5.060E-01,5.036E-01,4.995E-01,4.939E-01,4.874E-01,4.806E-01,4.720E-01,4.616E-01,4.492E-01,4.345E-01,4.176E-01,3.995E-01,3.804E-01,3.606E-01,3.405E-01,3.204E-01,3.001E-01,2.803E-01,2.612E-01,2.430E-01,2.257E-01,2.092E-01,1.937E-01,1.794E-01,1.672E-01,1.551E-01,1.434E-01,1.323E-01,1.218E-01,1.120E-01,1.028E-01,9.438E-02,8.661E-02,7.948E-02,7.182E-02,6.302E-02,5.511E-02,4.805E-02,4.177E-02,3.623E-02,3.135E-02,2.707E-02,2.333E-02,2.007E-02,1.723E-02,1.478E-02,1.265E-02,1.082E-02,9.243E-03,7.886E-03,6.722E-03,5.724E-03,4.871E-03,4.142E-03,3.520E-03,2.990E-03,2.539E-03,2.155E-03,1.828E-03,1.551E-03,1.316E-03,1.116E-03,9.469E-04,8.034E-04,6.819E-04,5.789E-04,4.917E-04,4.175E-04,3.547E-04,3.017E-04,2.568E-04,2.188E-04,1.866E-04,1.593E-04,1.362E-04,1.165E-04,9.978E-05,8.556E-05,7.344E-05,6.311E-05,5.429E-05,4.676E-05,4.031E-05,3.480E-05,3.007E-05,2.602E-05,2.254E-05,1.955E-05,1.697E-05,1.475E-05,1.284E-05,1.119E-05,9.762E-06,8.524E-06,7.451E-06,6.521E-06,5.735E-06,5.047E-06,4.443E-06,3.911E-06,3.442E-06,3.028E-06,2.662E-06,2.339E-06,2.053E-06,1.804E-06,1.584E-06,1.389E-06,1.217E-06,1.065E-06,9.298E-07,8.110E-07,7.063E-07,6.142E-07,5.333E-07,4.625E-07,4.004E-07,3.463E-07,2.991E-07,2.580E-07,2.222E-07,1.912E-07,1.644E-07,1.411E-07,1.211E-07,1.037E-07,8.880E-08,7.595E-08,6.489E-08,5.540E-08,4.726E-08,4.029E-08,3.431E-08,2.920E-08,2.484E-08,2.111E-08,1.793E-08,1.522E-08,1.291E-08,1.094E-08,9.270E-09,7.849E-09,6.643E-09,5.618E-09,4.750E-09,4.013E-09,3.389E-09,2.861E-09,2.414E-09,2.036E-09,1.716E-09,1.446E-09,1.218E-09,1.026E-09,8.633E-10,7.264E-10,6.110E-10,5.138E-10,4.319E-10,3.630E-10,3.050E-10,2.562E-10,2.152E-10,1.807E-10,1.517E-10,1.273E-10,1.069E-10,8.973E-11,7.532E-11,6.323E-11,5.308E-11,4.457E-11,3.742E-11,3.144E-11,2.641E-11,2.220E-11,1.867E-11,1.570E-11,1.322E-11,1.113E-11,9.381E-12,7.912E-12,6.679E-12,5.644E-12,4.774E-12,4.042E-12,3.427E-12,2.909E-12,2.473E-12,2.106E-12,1.795E-12,1.533E-12,1.312E-12,1.124E-12,9.655E-13,8.307E-13,7.160E-13,6.184E-13,5.352E-13};

       if(outN==0) for(int i=1;i<250;i++) tab[i]=2*SPA[i-1];
          else     for(int i=1;i<250;i++) tab[i]= SPE[i-1];  
       tab[0]=mX/2;
     }  break;

     case 130:  // K0_L
     {  mX=0.49761,qX=0;
       if(mX>=Mass || outN > 1) return 0;
       double SPA[249]={2.017E-03,2.898E-03,3.828E-03,4.285E-03,4.420E-03,4.530E-03,4.694E-03,4.809E-03,4.912E-03,5.007E-03,5.096E-03,5.183E-03,5.267E-03,5.351E-03,5.434E-03,5.519E-03,5.605E-03,5.694E-03,5.784E-03,5.877E-03,5.973E-03,6.159E-03,4.642E-02,1.230E-01,2.185E-01,3.240E-01,4.343E-01,5.459E-01,6.562E-01,7.629E-01,8.645E-01,9.597E-01,1.047E+00,1.126E+00,1.196E+00,1.257E+00,1.307E+00,1.348E+00,1.378E+00,1.398E+00,1.408E+00,1.408E+00,1.399E+00,1.381E+00,1.355E+00,1.317E+00,1.271E+00,1.220E+00,1.170E+00,1.116E+00,1.054E+00,9.865E-01,9.160E-01,8.431E-01,7.689E-01,6.939E-01,6.189E-01,5.446E-01,4.717E-01,4.010E-01,3.332E-01,2.690E-01,2.093E-01,1.547E-01,1.064E-01,6.580E-02,3.554E-02,2.304E-02,2.282E-02,2.322E-02,2.360E-02,2.396E-02,2.430E-02,2.460E-02,2.489E-02,2.520E-02,2.551E-02,2.582E-02,2.612E-02,2.641E-02,2.667E-02,2.692E-02,2.716E-02,2.740E-02,2.763E-02,2.785E-02,2.807E-02,2.828E-02,2.848E-02,2.867E-02,2.886E-02,2.904E-02,2.921E-02,2.937E-02,2.953E-02,2.968E-02,2.983E-02,2.997E-02,3.010E-02,3.023E-02,3.035E-02,3.047E-02,3.058E-02,3.069E-02,3.079E-02,3.089E-02,3.098E-02,3.107E-02,3.115E-02,3.123E-02,3.131E-02,3.137E-02,3.143E-02,3.147E-02,3.153E-02,3.160E-02,3.167E-02,3.173E-02,3.177E-02,3.181E-02,3.186E-02,3.189E-02,3.193E-02,3.197E-02,3.200E-02,3.203E-02,3.206E-02,3.209E-02,3.211E-02,3.214E-02,3.216E-02,3.218E-02,3.220E-02,3.222E-02,3.224E-02,3.226E-02,3.227E-02,3.229E-02,3.230E-02,3.231E-02,3.232E-02,3.234E-02,3.235E-02,3.236E-02,3.236E-02,3.237E-02,3.238E-02,3.239E-02,3.239E-02,3.240E-02,3.241E-02,3.241E-02,3.242E-02,3.242E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02,3.243E-02};
       double SPE[249]={0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,3.317E-02,6.006E-02,8.435E-02,1.066E-01,1.272E-01,1.467E-01,1.653E-01,1.834E-01,2.012E-01,2.186E-01,2.353E-01,2.512E-01,2.663E-01,2.805E-01,2.938E-01,3.062E-01,3.176E-01,3.581E-01,4.024E-01,4.471E-01,4.880E-01,5.253E-01,5.588E-01,5.883E-01,6.247E-01,6.762E-01,7.214E-01,7.605E-01,7.934E-01,8.204E-01,8.418E-01,8.577E-01,8.686E-01,8.748E-01,8.766E-01,8.746E-01,8.689E-01,8.601E-01,8.484E-01,8.346E-01,8.182E-01,7.992E-01,7.782E-01,7.535E-01,7.246E-01,6.917E-01,6.558E-01,6.175E-01,5.773E-01,5.362E-01,4.947E-01,4.528E-01,4.110E-01,3.709E-01,3.330E-01,2.975E-01,2.642E-01,2.338E-01,2.060E-01,1.810E-01,1.585E-01,1.384E-01,1.206E-01,1.047E-01,9.078E-02,7.852E-02,6.778E-02,5.840E-02,5.024E-02,4.315E-02,3.701E-02,3.170E-02,2.712E-02,2.317E-02,1.978E-02,1.686E-02,1.436E-02,1.222E-02,1.039E-02,8.828E-03,7.495E-03,6.360E-03,5.393E-03,4.570E-03,3.872E-03,3.279E-03,2.776E-03,2.350E-03,1.989E-03,1.683E-03,1.424E-03,1.205E-03,1.020E-03,8.635E-04,7.312E-04,6.195E-04,5.251E-04,4.453E-04,3.779E-04,3.204E-04,2.719E-04,2.309E-04,1.964E-04,1.672E-04,1.426E-04,1.217E-04,1.040E-04,8.906E-05,7.635E-05,6.555E-05,5.637E-05,4.855E-05,4.188E-05,3.619E-05,3.132E-05,2.716E-05,2.358E-05,2.052E-05,1.788E-05,1.561E-05,1.366E-05,1.197E-05,1.050E-05,9.234E-06,8.131E-06,7.172E-06,6.335E-06,5.601E-06,4.956E-06,4.390E-06,3.890E-06,3.449E-06,3.061E-06,2.717E-06,2.413E-06,2.142E-06,1.902E-06,1.698E-06,1.518E-06,1.356E-06,1.209E-06,1.075E-06,9.543E-07,8.450E-07,7.464E-07,6.577E-07,5.782E-07,5.071E-07,4.438E-07,3.875E-07,3.377E-07,2.937E-07,2.550E-07,2.209E-07,1.911E-07,1.651E-07,1.424E-07,1.226E-07,1.054E-07,9.056E-08,7.769E-08,6.656E-08,5.696E-08,4.869E-08,4.159E-08,3.548E-08,3.024E-08,2.575E-08,2.191E-08,1.862E-08,1.582E-08,1.343E-08,1.139E-08,9.651E-09,8.173E-09,6.917E-09,5.850E-09,4.944E-09,4.176E-09,3.525E-09,2.974E-09,2.508E-09,2.113E-09,1.780E-09,1.498E-09,1.260E-09,1.060E-09,8.905E-10,7.480E-10,6.279E-10,5.269E-10,4.419E-10,3.705E-10,3.104E-10,2.600E-10,2.176E-10,1.821E-10,1.523E-10,1.273E-10,1.064E-10,8.885E-11,7.417E-11,6.190E-11,5.163E-11,4.304E-11,3.587E-11,2.988E-11,2.488E-11,2.071E-11,1.723E-11,1.433E-11,1.191E-11,9.898E-12,8.221E-12,6.826E-12,5.665E-12,4.699E-12,3.897E-12,3.230E-12,2.676E-12,2.217E-12,1.835E-12,1.519E-12,1.256E-12,1.039E-12,8.587E-13,7.095E-13,5.860E-13,4.838E-13,3.993E-13,3.294E-13};

       if(outN==0) for(int i=1;i<250;i++) tab[i]=2*SPA[i-1];
          else     for(int i=1;i<250;i++) tab[i]= SPE[i-1];  
       tab[0]=mX/2;
     }  break;
     case 310:  // K0_S
     {  mX=0.49761,qX=0;
       if(mX>=Mass || outN > 1) return 0;
       double SPA[249]={2.485E-11,2.475E-11,2.457E-11,2.433E-11,2.405E-11,2.374E-11,2.340E-11,2.304E-11,1.329E+00,1.306E+00,1.281E+00,1.256E+00,1.230E+00,1.204E+00,1.177E+00,1.150E+00,1.123E+00,1.095E+00,1.068E+00,1.040E+00,1.012E+00,9.847E-01,9.573E-01,9.299E-01,9.029E-01,8.760E-01,8.495E-01,8.233E-01,7.974E-01,7.720E-01,7.470E-01,7.224E-01,6.982E-01,6.745E-01,6.514E-01,6.287E-01,6.065E-01,5.848E-01,5.637E-01,5.431E-01,5.230E-01,5.035E-01,4.845E-01,4.661E-01,4.482E-01,4.308E-01,4.139E-01,3.976E-01,3.818E-01,3.665E-01,3.517E-01,3.374E-01,3.236E-01,3.103E-01,2.975E-01,2.851E-01,2.732E-01,2.617E-01,2.507E-01,2.401E-01,2.299E-01,2.201E-01,2.107E-01,2.017E-01,1.931E-01,1.848E-01,1.769E-01,1.693E-01,1.621E-01,1.552E-01,1.486E-01,1.422E-01,1.362E-01,1.585E-02,1.621E-02,1.657E-02,1.692E-02,1.726E-02,1.759E-02,1.792E-02,1.824E-02,1.854E-02,1.884E-02,1.912E-02,1.940E-02,1.967E-02,1.993E-02,2.017E-02,2.041E-02,2.065E-02,2.087E-02,2.108E-02,2.129E-02,2.149E-02,2.168E-02,2.186E-02,2.204E-02,2.221E-02,2.237E-02,2.253E-02,2.268E-02,2.282E-02,2.296E-02,2.309E-02,2.321E-02,2.333E-02,2.345E-02,2.356E-02,2.366E-02,2.378E-02,2.389E-02,2.396E-02,2.431E-02,2.514E-02,2.508E-02,2.483E-02,2.462E-02,2.451E-02,2.448E-02,2.450E-02,2.454E-02,2.459E-02,2.464E-02,2.468E-02,2.472E-02,2.476E-02,2.480E-02,2.483E-02,2.487E-02,2.490E-02,2.493E-02,2.496E-02,2.498E-02,2.500E-02,2.503E-02,2.505E-02,2.507E-02,2.509E-02,2.510E-02,2.512E-02,2.514E-02,2.515E-02,2.516E-02,2.517E-02,2.519E-02,2.520E-02,2.521E-02,2.522E-02,2.523E-02,2.523E-02,2.524E-02,2.525E-02,2.525E-02,2.526E-02,2.527E-02,2.527E-02,2.528E-02,2.528E-02,2.529E-02,2.529E-02,2.529E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02,2.530E-02};
       double SPE[249]={0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,0.000E+00,1.247E-03,4.860E-03,1.116E-02,2.027E-02,3.233E-02,4.740E-02,6.551E-02,8.664E-02,1.107E-01,1.377E-01,1.674E-01,1.997E-01,2.343E-01,2.712E-01,3.099E-01,3.503E-01,3.922E-01,4.351E-01,4.789E-01,5.234E-01,5.680E-01,6.098E-01,6.480E-01,6.819E-01,7.092E-01,7.333E-01,7.537E-01,7.706E-01,7.833E-01,7.902E-01,7.946E-01,7.973E-01,7.979E-01,7.941E-01,7.876E-01,7.797E-01,7.696E-01,7.573E-01,7.423E-01,7.260E-01,7.093E-01,6.919E-01,6.740E-01,6.555E-01,6.367E-01,6.175E-01,5.980E-01,5.783E-01,5.582E-01,5.379E-01,5.178E-01,4.979E-01,4.784E-01,4.591E-01,4.402E-01,4.217E-01,4.036E-01,3.861E-01,3.690E-01,3.522E-01,3.364E-01,3.215E-01,3.063E-01,2.906E-01,2.744E-01,2.644E-01,2.499E-01,2.325E-01,2.136E-01,1.941E-01,1.749E-01,1.564E-01,1.389E-01,1.227E-01,1.078E-01,9.438E-02,8.229E-02,7.152E-02,6.199E-02,5.361E-02,4.627E-02,3.987E-02,3.429E-02,2.944E-02,2.524E-02,2.161E-02,1.847E-02,1.578E-02,1.346E-02,1.147E-02,9.765E-03,8.308E-03,7.062E-03,5.999E-03,5.093E-03,4.322E-03,3.666E-03,3.109E-03,2.635E-03,2.234E-03,1.893E-03,1.604E-03,1.360E-03,1.152E-03,9.771E-04,8.287E-04,7.031E-04,5.968E-04,5.047E-04,4.271E-04,3.622E-04,3.077E-04,2.619E-04,2.233E-04,1.908E-04,1.632E-04,1.398E-04,1.199E-04,1.030E-04,8.864E-05,7.634E-05,6.582E-05,5.681E-05,4.908E-05,4.245E-05,3.674E-05,3.183E-05,2.760E-05,2.396E-05,2.082E-05,1.810E-05,1.575E-05,1.372E-05,1.195E-05,1.043E-05,9.103E-06,7.955E-06,6.958E-06,6.092E-06,5.337E-06,4.679E-06,4.107E-06,3.607E-06,3.169E-06,2.786E-06,2.450E-06,2.165E-06,1.917E-06,1.696E-06,1.499E-06,1.323E-06,1.166E-06,1.026E-06,9.007E-07,7.894E-07,6.906E-07,6.030E-07,5.256E-07,4.573E-07,3.972E-07,3.444E-07,2.982E-07,2.578E-07,2.225E-07,1.918E-07,1.651E-07,1.419E-07,1.219E-07,1.045E-07,8.953E-08,7.662E-08,6.550E-08,5.594E-08,4.773E-08,4.068E-08,3.465E-08,2.949E-08,2.507E-08,2.130E-08,1.808E-08,1.534E-08,1.300E-08,1.102E-08,9.325E-09,7.889E-09,6.670E-09,5.636E-09,4.759E-09,4.016E-09,3.388E-09,2.856E-09,2.406E-09,2.026E-09,1.705E-09,1.434E-09,1.206E-09,1.013E-09,8.508E-10,7.142E-10,5.993E-10,5.026E-10,4.213E-10,3.529E-10,2.956E-10,2.474E-10,2.070E-10,1.731E-10,1.447E-10,1.209E-10,1.010E-10,8.430E-11,7.035E-11,5.867E-11,4.892E-11,4.077E-11,3.396E-11,2.828E-11,2.353E-11,1.958E-11,1.628E-11,1.354E-11,1.125E-11,9.342E-12,7.756E-12,6.437E-12,5.340E-12,4.428E-12,3.670E-12,3.041E-12,2.519E-12,2.085E-12,1.726E-12,1.427E-12,1.180E-12,9.756E-13,8.061E-13,6.658E-13,5.497E-13,4.536E-13,3.742E-13};

       if(outN==0) for(int i=1;i<250;i++) tab[i]=2*SPA[i-1];
          else     for(int i=1;i<250;i++) tab[i]= SPE[i-1];  
       tab[0]=mX/2;
     }  break;
  } 

  if(mX>0)
  {  if(Mass<mX) return 0;
     if(outN>1)  return 0; 
     double Y=acosh(Mass/mX);  
     
     if(outN==0) 
     { boost(Y,Mass, 0, tab); 
       if(qX) for(int i=1;i<NZ;i++){double E=Mass*exp(Zi(i)); tab[i]+=E*qX*qX*FSRdNdE(E,sqrt(Mass*Mass-mX*mX),mX, 1, 1,0);}
     } else boost(Y,Mass, Me, tab); 
     return 0;    
  }
  
  int inP=-1;

  switch(N)
  { case 21:inP=0; break;  /*glu*/ 
    case 1: case 2: case 3: case 4: case 5: case 6:  inP=N; break; /* d,u,s,c,b,t*/
    case 11:case 13: case 15: inP=(N+1)/2+1; break; /*e,m,l*/  
    case 23:    inP=10; break;  /*z*/
    case 23+'T':inP=11; break;  
    case 23+'L':inP=12; break;     
    case 24:    inP=13; break;  /*w*/
    case 24+'T':inP=14; break;
    case 24+'L':inP=15; break;
  }
  if(inP==-1) return 2;
  readSpectra(); 
  double tab250[250];
  mInterp(Mass,inP,outN,tab250);
  
  for(int i=1;i<NZ && i<250  ;i++) tab[i]=tab250[i];
        
  return 0;
}

//=================================================

//#define NEn 36  /* Number of Energy points for interpolation */
#undef Nin
#define Nin 21 
//#define Nout 7

static float phidiff_[Nin][Nout][NEn][250];


static int readSpectra_(void)
{ static int rdOk=0;
  int k,l,i,n;
  FILE *f;
  char * buff;
  char *fnames[Nin]={"gg.dat","dd.dat","uu.dat","ss.dat","cc.dat",
                     "bb.dat","tt.dat","ee.dat","mm.dat","ll.dat",
                     "zz.dat","zz_t.dat","zz_l.dat",
                     "ww.dat","ww_t.dat","ww_l.dat",
                     "pi0pi0.dat","pippim.dat","klkl.dat","ksks.dat","kpkm.dat"};

  if(rdOk) return 0;
  buff=malloc(strlen(micrO)+100);

  for(n=0;n<Nin;n++)
  {  sprintf(buff,"%s/Data/spectPythia6/%s",micrO,fnames[n]);
     f=  fopen(buff,"r");
//     fclose(f); f=NULL;
     
     if(f==NULL) { free(buff);return 1;}    
     for(i=0;i<6;i++)
     { char ppp[20];
       fscanf(f,"%s",ppp);
       for(k=0;k<NEn;k++)
       {
         for(l=0;l<250;l++) if(1!=fscanf(f,"%f",phidiff_[n][i][k]+l)) break;
         fscanf(f,"%*s"); 
         for(;l<250;l++)phidiff_[n][i][k][l]=0;
       }
     }
//printf("ok before fclose\n");     
     fclose(f);
  }
    
  
  free(buff);
  rdOk=1;   
  
  return 0;
}

static void mInterp_(double Nmass,  int  CHin,int  CHout, double*tab)
{  
   double mi[NEn]={0.105,0.15,0.2,0.3,0.5,0.8,1.1,1.5, 2 ,5 ,10,25,50,80.3,85,91.2,92,95,100,110,120,125,130,140,150,176,200,250,350,500,750,1000,1500,2000,3000,5000};
//                  0     1    2   3   4   5   6   7   8  9  10 11 12   13 14  15  16 17  18  19  20  21  22  23  24  25
   int l,i0;
   double c0,c1;
   float *p0,*p1;
   for(i0=0; i0<NEn && Nmass>=mi[i0] ;i0++);
   if(i0) i0--;

   int i00=-1;
   switch(CHin)  /* below pole mass and/or below end of table */
   { 
     case  0: case 1: case 2: case 3: case 4: case 7:
                                   if(i0<8)  i00=8;  break; /* G,d,u,s,c  M=2  */
     case  9:                      if(i0<8)  i00=8;  break; /* for l      M=1.5*/      
     case  6:                      if(i0<25) i00=25; break; /* t m<17          */
     case 13: case 14: case 15:    if(i0<14) i00=14; break; /* W m<80.3        */
     case 10: case 11: case 12:    if(i0<15) i00=15; break; /* Z m<91.2        */
   } 

   if(i00>=0) 
   {  for(l=1;l<250;l++) tab[l]=phidiff_[CHin][CHout][i00][l-1]; 
      tab[0]=Nmass; 
      if(CHout==2 || CHout==6) 
      {  double C=0;
         double Mout=0.938;
         if(Nmass>Mout)  C=  (Nmass-Mout)/(mi[i00]-Mout);  //* (mi[i00]+2*Mout)/(Nmass+2*Mout);     //C=(decayPcm(2*Nmass,Mout,Mout)/Nmass)/ (decayPcm(2*mi[i00],Mout,Mout)/mi[i00]);
         for(l=1;l<250;l++) tab[l]*=C;
      }   
      return;
   }
   p0=phidiff_[CHin][CHout][i0];
   p1=phidiff_[CHin][CHout][i0+1];
   if(i0==NEn-1 || (Nmass<=2 && CHin >100) ) for(l=1;l<250;l++) tab[l]= p0[l-1];
   else
   {
//     c1=(Nmass*Nmass -mi[i0]*mi[i0])/(mi[i0+1]*mi[i0+1] - mi[i0]*mi[i0]);
     c1=(log(Nmass)-log(mi[i0]))/(log(mi[i0+1])-log(mi[i0]));
     c0=1-c1;
     for(l=1;l<250;l++) tab[l]= c0*p0[l-1]+c1*p1[l-1];
   }
   tab[0]=Nmass;
}

#define Me (5E-4)
#define Mm (0.105)

static int basicSpectraS_(double Mass, int pdgN, int outN, double * tab)
{ 
//  printf("basicSpectra: pdg=%d outN=%d\n", pdgN, outN);
  tab[0]=Mass;
  for(int i=1;i<NZ;i++) tab[i]=0;
  if(outN<0 ||  outN>5  ) return 1;
//  if(Mass<2) return 3;
  int N=abs(pdgN);
  
  if(useBoost && N==13)
  { double Sp0[NZ];
    double Y=acosh(Mass/Mm);
    switch (outN)
    {
       case 0:   
           fillSpect(muonRestA, Mm/2, Sp0);
           boost(Y,Mass, 0,  Sp0); 
           for(int i=1;i<NZ;i++){ double  E=Mass*exp(Zi(i)); tab[i]=2*Sp0[i]+ E*FSRdNdE(E,sqrt(Mass*Mass-Mm*Mm),Mm, 1, 1,0);}
           return 0;
       
       case 1: 
          fillSpect(muonRestE, Mm/2, Sp0);
          boost(Y,Mass, Me,  Sp0);
          for(int i=0;i<NZ;i++) tab[i]=Sp0[i]; 
          return 0;       
    }
  
  }
  if( N==22 && outN==0){ tab[1]=2*D1; tab[2]=2*D2; return 0;}      
  if((N==12 || N==14 || N==16) && 2*outN==N-6) { tab[1]+=D1; tab[2]+=D2; return 0; }  
  int inP=-1;

  switch(N)
  { case 21:inP=0; break;  /*glu*/ 
    case 1: case 2: case 3: case 4: case 5: case 6:  inP=N; break; /* d,u,s,c,b,t*/
    case 11:case 13: case 15: inP=(N+1)/2+1; break; /*e,m,l*/  
    case 23:    inP=10; break;  /*z*/
    case 23+'T':inP=11; break;  
    case 23+'L':inP=12; break;     
    case 24:    inP=13; break;  /*w*/
    case 24+'T':inP=14; break;
    case 24+'L':inP=15; break;
    case 111   :inP=16; break;
    case 211   :inP=17; break;
    case 130   :inP=18; break; // K0_L
    case 310   :inP=19; break; // k0_S
    case 321   :inP=20; break;
  }
  if(inP==-1) return 2;
  readSpectra_(); 
  double tab250[250];
  mInterp_(Mass,inP,outN,tab250);
  
  for(int i=1;i<NZ && i<250  ;i++) tab[i]=tab250[i];
  

  if(N==11 && outN==0)
  { 
     if(outN==0 && Mass<2)
     {  double me=5.11E-4;
        if(Mass<me) for(int i=1;i<NZ;i++) tab[i]=0; else 
        { 
          for(int i=1;i<NZ;i++)
          {
             double E=Mass*exp(Zi(i));
             tab[i]=E*FSRdNdE(E,Mass,me,1,1,0);    
          }  
        } 
     }
  }
      
  return 0;
}
#undef Me 
#undef Mm

#undef NEn 
#undef Nin  
#undef Nout 


#define Nch   25
#define NM    62
#define NX    179
#define Nout  7

static int basicSpectraPPPC(double Mass, int pdgN, int outN, double * tab)
{
   pdgN=abs(pdgN); 
   tab[0]=Mass;
   for(int i=1;i<NZ;i++) tab[i]=0;
   if(outN<0 || outN>6) return 1;
//   if(Mass<5) return 3;
   static int init=0;
   static double dmMass[NM], x[NX];

   static float phidiffPPPC[Nch][Nout][NM][NX]; 
   
   if(init==0)
   {
//printf("READ\n");
      char* src[Nout]=
      {
         "AtProduction_gammas.dat", "AtProduction_positrons.dat", "AtProduction_antiprotons.dat"
        , "AtProduction_neutrinos_e.dat", "AtProduction_neutrinos_mu.dat", "AtProduction_neutrinos_tau.dat"
        , "AtProduction_antideuterons.dat"            
      };
      for(int i=0;i<Nch;i++) for(int j=0;j<Nout;j++) for(int k=0;k<NM;k++) for(int l=0;l<NX;l++) phidiffPPPC[i][j][k][l]=0;

      char* buff;
      buff=malloc(strlen(micrO)+100);

      for(int k=0;k<Nout;k++) 
      { 
         sprintf(buff,"%s/Data/PPPC/%s",micrO,src[k]); 
         FILE*F=fopen(buff,"r"); 
         if(!F) 
         {  char* command =malloc(strlen(micrO)+30);
            sprintf(command,"make -C %s/Data/PPPC",micrO);
            system(command);
            free(command);
            F=fopen(buff,"r"); 
            if(!F) { printf("Can not downdoad PPPC spectra\n"); exit(1);}
         }   
         fscanf(F,"%*[^\n]\n");
         for(int m=0;m<NM;m++) for(int ix=0;ix<NX;ix++)
         {  fscanf(F,"%lf %lf",dmMass+m,x+ix);
//             printf("M[%d]=%E x[%d]=%E\n",m,dmMass[m],ix,pow(10,x[ix]));     
            for(int ich=0;ich<Nch;ich++) fscanf(F,"%f",&(phidiffPPPC[ich][k][m][ix]));
            fscanf(F,"%*[^\n]\n");
         }
         fclose(F);
               
         for(int m=0;m<NM;m++) for(int ix=0;ix<NX;ix++)for(int ich=0;ich<Nch;ich++) phidiffPPPC[ich][k][m][ix]/=log(10);
      }
//      exit(0);
      free(buff);
      for(int ix=0;ix<NX;ix++)  x[ix]=pow(10,x[ix]);           
      init=1;
   } 

//eL,eR, e,mL,mR, m,lL,lR, l, q, c, b, t,WL,WT, W,ZL,ZT, Z, g, A, h, nu_e,nu_m,nu_l
//0   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20  21  22  23   24 

  int ch=-1;
  switch(pdgN) 
  { case 1  :  case 2 : case 3: 
                  ch=9 ; break;
    case 4      : ch=10; break;
    case 5      : ch=11; break;
    case 6      : ch=12; break;
    case 11+'L' : ch=0 ; break;
    case 11+'R' : ch=1 ; break;
    case 11     : ch=2 ; break;
    case 13+'L' : ch=3 ; break;
    case 13+'R' : ch=4 ; break;
    case 13     : ch=5 ; break;
    case 15+'L' : ch=6 ; break;
    case 15+'R' : ch=7 ; break;
    case 15     : ch=8 ; break;
    case 21     : ch=19; break;
    case 22     : ch=20; break;
    case 24+'L' : ch=13; break;
    case 24+'T' : ch=14; break;
    case 24     : ch=15; break;
    case 23+'L' : ch=16; break;
    case 23+'T' : ch=17; break;
    case 23     : ch=18; break;
    case 25     : ch=21; break;
    case 12     : ch=22; break;
    case 14     : ch=23; break;
    case 16     : ch=24; break;
  }

  if(ch<0) return 2;
  double stab[NX];
       if(Mass<=dmMass[0])    for(int ix=0;ix<NX;ix++) stab[ix]=phidiffPPPC[ch][outN][0][ix];
  else if(Mass>=dmMass[NM-1]) for(int ix=0;ix<NX;ix++) stab[ix]=phidiffPPPC[ch][outN][NM-1][ix];
  else
  { 
     int m;
     for(m=0;m<NM && Mass>dmMass[m];m++) continue;
     m--;
//     double a=(Mass-dmMass[m])/(dmMass[m+1]-dmMass[m]);    
     double a=(log(Mass)-log(dmMass[m]))/(log(dmMass[m+1])-log(dmMass[m]));

     for(int ix=0;ix<NX;ix++)  stab[ix]=(1-a)*phidiffPPPC[ch][outN][m][ix]+a*phidiffPPPC[ch][outN][m+1][ix];   
  }

  for(int i=1;i<NZ;i++) { double y=exp(Zi(i)); if(y<x[0]) tab[i]=0; else  tab[i]=polint1(y, NX, x, stab);}
//for(int i=0;i<NX;i++) printf("x=%e f=%e\n", x[i],stab[i]);  
   
  return 0;
}

#undef Nch  // 25
#undef NM   // 62
#undef NX   // 179   

#define Nch   29
#define NM    62
#define NX    100


static int basicSpectraCosmiXs(double Mass, int pdgN, int outN, double * tab)
{
   pdgN=abs(pdgN);
   tab[0]=Mass;
   for(int i=1;i<NZ;i++) tab[i]=0;
   if(outN<0 || outN>5) return 1;
//   if(Mass<5) return 3;
   static int init=0;
   static double dmMass[NM], x[NX];

   static float phidiffPPPC[Nch][Nout-1][NM][NX]; 

   if(init==0)
   {
//printf("READ\n");
      char* src[Nout-1]=
      {
           "AtProduction-Gamma.dat", "AtProduction-Positrons.dat",  "AtProduction-AntiP.dat", "AtProduction-Nuel.dat",  "AtProduction-Numu.dat", "AtProduction-Nuta.dat"              
      };
      for(int i=0;i<Nch;i++) for(int j=0;j<Nout-1;j++) for(int k=0;k<NM;k++) for(int l=0;l<NX;l++) phidiffPPPC[i][j][k][l]=0;

      char* buff;
      buff=malloc(strlen(micrO)+100);

      for(int k=0;k<Nout-1;k++) 
      { 
         sprintf(buff,"%s/Data/CosmiXs/%s",micrO,src[k]); 
         FILE*F=fopen(buff,"r"); 
         if(!F) 
         {  char* command =malloc(strlen(micrO)+30);
            sprintf(command,"make -C %s/Data/CosmiXs",micrO);
            system(command);
            free(command);
            F=fopen(buff,"r"); 
            if(!F) { printf("Can not downdoad CosmiXs spectra\n"); exit(1);}
         }   


//printf("F=%p\n",F);
         fscanf(F,"%*[^\n]\n");
         for(int m=0;m<NM;m++) for(int ix=0;ix<NX;ix++)
         {  fscanf(F,"%lf %lf",dmMass+m,x+ix);
//             printf("M[%d]=%E x[%d]=%E\n",m,dmMass[m],ix,pow(10,x[ix]));     
            for(int ich=0;ich<Nch;ich++) fscanf(F,"%f",&(phidiffPPPC[ich][k][m][ix]));
            fscanf(F,"%*[^\n]\n");
         }
         fclose(F);
               
         for(int m=0;m<NM;m++) for(int ix=0;ix<NX;ix++)for(int ich=0;ich<Nch;ich++) phidiffPPPC[ich][k][m][ix]/=log(10);
      }
//      exit(0);
      free(buff);
      for(int ix=0;ix<NX;ix++)  x[ix]=pow(10,x[ix]);           
      init=1;
   } 

// eL eR  e  muL  muR   mu tauL  tauR  tau   nue  numu   nutau   u d  s  c  b   t  a  g  W   WL  WT  Z  ZL ZT H  aZ HZ 
// 0   1  2  3     4     5   6     7    8     9    10     11    12 13 14 15 16 17 18 19  20  21  22  23 24 25 26 27 28


  int ch=-1;
  switch(pdgN) 
  { case 1      : ch=13; break;        
    case 2      : ch=12; break;
    case 3      : ch=14 ;break;
    case 4      : ch=15; break;
    case 5      : ch=16; break;
    case 6      : ch=17; break;
    case 11+'L' : ch=0 ; break;
    case 11+'R' : ch=1 ; break;
    case 11     : ch=2 ; break;
    case 13+'L' : ch=3 ; break;
    case 13+'R' : ch=4 ; break;
    case 13     : ch=5 ; break;
    case 15+'L' : ch=6 ; break;
    case 15+'R' : ch=7 ; break;
    case 15     : ch=8 ; break;
    case 21     : ch=19; break;
    case 22     : ch=18; break;
    case 24+'L' : ch=21; break;
    case 24+'T' : ch=22; break;
    case 24     : ch=20; break;
    case 23+'L' : ch=24; break;
    case 23+'T' : ch=25; break;
    case 23     : ch=23; break;
    case 25     : ch=26; break;
    case 12     : ch=9;  break;
    case 14     : ch=10; break;
    case 16     : ch=11; break;
  }
  if(ch<0) return 2;
  
  double stab[NX];
       if(Mass<=dmMass[0])    for(int ix=0;ix<NX;ix++) stab[ix]=phidiffPPPC[ch][outN][0][ix];
  else if(Mass>=dmMass[NM-1]) for(int ix=0;ix<NX;ix++) stab[ix]=phidiffPPPC[ch][outN][NM-1][ix];
  else
  { 
     int m;
     for(m=0;m<NM && Mass>dmMass[m];m++) continue;
     m--;
//     double a=(Mass-dmMass[m])/(dmMass[m+1]-dmMass[m]);
     double a=(log(Mass)-log(dmMass[m]))/(log(dmMass[m+1])-log(dmMass[m]));
     for(int ix=0;ix<NX;ix++)  stab[ix]=(1-a)*phidiffPPPC[ch][outN][m][ix]+a*phidiffPPPC[ch][outN][m+1][ix];   
  }

  for(int i=1;i<NZ;i++) { double y=exp(Zi(i)); if(y<x[0]) tab[i]=0; else  tab[i]=polint1(y, NX, x, stab);}
  
  if(pdgN==22 && outN==0) { tab[1]+=2*D1; tab[2]+=2*D2;}
  if((pdgN==12 || pdgN==14 || pdgN==16) && 2*outN==pdgN-6) { tab[1]+=D1; tab[2]+=D2; }  

   
  return 0;
}

#undef Nch  // 25
#undef NM   // 62
#undef NX   // 179   




#define Nch   14
#define NM    60
#define NX    180   


static int basicSpectraA(double Mass, int pdgN, int outN, double * tab)
{
   pdgN=abs(pdgN);
   tab[0]=Mass;
   for(int i=1;i<NZ;i++) tab[i]=0;
   if(outN<0 || outN>5) return 1;
//   if(Mass<5) return 3;
   
   static int init=0;
   static double dmMass[NM], x[NX];

   static float phidiffA[Nch][Nout-1][NM][NX]; 

   if(init==0)
   {
//printf("READ\n");
      char* src[Nout-1]={"AtProduction-Ga.dat",  "AtProduction-Positrons.dat", "AtProduction-AntiP.dat",  
                    "AtProduction-Nuel.dat","AtProduction-Numu.dat",      "AtProduction-Nuta.dat"};
      for(int i=0;i<Nch;i++) for(int j=0;j<Nout-1;j++) for(int k=0;k<NM;k++) for(int l=0;l<NX;l++) phidiffA[i][j][k][l]=0;

      char* buff;
      buff=malloc(strlen(micrO)+100);

      for(int k=0;k<Nout-1;k++) 
      { 
         sprintf(buff,"%s/Data/woUncertainty/%s",micrO,src[k]); 
         FILE*F=fopen(buff,"r"); 
         if(!F) 
         {  char* command =malloc(strlen(micrO)+30);
            sprintf(command,"make -C %s/Data/woUncertainty",micrO);
            system(command);
            free(command);
            F=fopen(buff,"r"); 
            if(!F) { printf("Can not downdoad Pythia_8 spectra\n"); exit(1);}
         }   
        
//printf("F=%p\n",F);
         fscanf(F,"%*[^\n]\n");
         for(int m=0;m<NM;m++) for(int ix=0;ix<NX;ix++)
         {  fscanf(F,"%lf %lf",dmMass+m,x+ix); /*printf("M=%E x=%E\n",dmMass[m],x[ix]);*/     for(int ich=0;ich<Nch;ich++){    fscanf(F,"%f",&(phidiffA[ich][k][m][ix]));}
         }
         
         for(int m=0;m<NM;m++) for(int ix=0;ix<NX;ix++)for(int ich=0;ich<Nch;ich++) phidiffA[ich][k][m][ix]/=log(10);
         fclose(F);   
      }
      free(buff);
      init=1;
   } 

  if((pdgN==12 || pdgN==14 || pdgN==16) && 2*outN==pdgN-6) { tab[1]+=D1; tab[2]+=D2; return 0; }  


//     [ee]  [mumu] [tautau]  [uu]  [dd]  [ss]  [cc]  [bb]  [tt] [gaga]  [zz]  [ww]   [gg]  [hh]
//      0     1       2         3    4      5     6    7     8     9      10    11     12    13

  int ch=-1;
  switch(pdgN) 
  { case 1  : ch=4 ; break;
    case 2  : ch=3 ; break;
    case 3  : ch=5 ; break;
    case 4  : ch=6 ; break;
    case 5  : ch=7 ; break;
    case 6  : ch=8 ; break;
    case 11 : ch=0 ; break;
    case 13 : ch=1 ; break;
    case 15 : ch=2 ; break;
    case 21 : ch=12; break;
    case 22 : ch=9 ; break;
    case 23 : ch=10; break;
    case 24 : ch=11; break;
    case 25 : ch=13; break;
  }
   
  if(ch<0) return 2;
  
  double stab[NX];
       if(Mass<=dmMass[0])    for(int ix=0;ix<NX;ix++) stab[ix]=phidiffA[ch][outN][0][ix];
  else if(Mass>=dmMass[NM-1]) for(int ix=0;ix<NX;ix++) stab[ix]=phidiffA[ch][outN][NM-1][ix];
  else
  { 
     int m;
     for(m=0;m<NM && Mass>dmMass[m];m++) continue;
     m--;
//     double a=(Mass-dmMass[m])/(dmMass[m+1]-dmMass[m]);
     double a=(log(Mass)-log(dmMass[m]))/(log(dmMass[m+1])-log(dmMass[m]));
     for(int ix=0;ix<NX;ix++)  stab[ix]=(1-a)*phidiffA[ch][outN][m][ix]+a*phidiffA[ch][outN][m+1][ix];   
  }

  for(int i=1;i<NZ;i++) { double y=exp(Zi(i)); if(y<x[0]) tab[i]=0; else  tab[i]=polint1(y, NX, x, stab);}
  
  if( pdgN==22 && outN==0 ) { tab[1]+=2*D1; tab[2]+=2*D2; }
 
  return 0;
}


int  spectUncert=0,DHad=1,DScale=1,DcNS=1;

int spectraUncertainty(double Mass, int pdgN, int outN, double * tab)
{
   pdgN=abs(pdgN);
   tab[0]=Mass;
   for(int i=1;i<NZ;i++) tab[i]=0;
   if(outN<0|| outN>2) return 1;
   if(Mass<5) return 3;
   if(!spectUncert) return 0;
   if(pdgN==12 || pdgN==14 || pdgN==16) return 0;

   static int init=0;
   static double dmMass[NM], x[NX];

   static float phidiffU[Nch][3][NM][NX][6]; 

   
   if(init==0)
   {
//printf("READ\n");
      char* src[3]={"AtProduction-Ga.dat",  "AtProduction-Positrons.dat", "AtProduction-AntiP.dat"};
//                  ,"AtProduction-Nuel.dat","AtProduction-Numu.dat",      "AtProduction-Nuta.dat"};

      char* buff;
      buff=malloc(strlen(micrO)+100);

      for(int k=0;k<3;k++) 
      { 
         sprintf(buff,"%s/Data/wUncertainty/%s",micrO,src[k]); 
         FILE*F=fopen(buff,"r"); 
         if(!F) 
         {  char* command =malloc(strlen(micrO)+30);
            sprintf(command,"make -C %s/Data/wUncertainty",micrO);
            system(command);
            free(command);
            F=fopen(buff,"r"); 
            if(!F) { printf("Can not downdoad  spectra uncertainty\n"); exit(1);}
         }   


         fscanf(F,"%*[^\n]\n");
int ln=2;         
         for(int m=0;m<NM;m++) for(int ix=0;ix<NX;ix++)
         {  double  zm,zx;
            fscanf(F,"%lf %lf",&zm,&zx);   
//            printf("m=%E  x[%d]=%E\n",zm,ix,zx); 
            if((ix && zm!=dmMass[m])|| m && zx!=x[ix]) { printf("error l=%d\n",ln); exit(0);} 
            if(m==0) x[ix]=zx;
            if(ix==0) dmMass[m]=zm;  
              long nfB=ftell(F);
              fscanf(F,"%*[^\n]");
              long nfE=ftell(F);
              fseek(F,nfB,SEEK_SET);
            for(int ich=0;ich<Nch;ich++) 
            { char bu[100]; 
              fscanf(F,"%s",bu);
              for(int l=0;l<6;l++) 
              fscanf(F,"%f",&(phidiffU[ich][k][m][ix][l]));
            }
//            if(ftell(F)> nfE)  printf("error in line %d\n",ln);
            if(ftell(F)> nfE) { fseek(F,nfE,SEEK_SET); for(int ich=0;ich<Nch;ich++)for(int l=0;l<6;l++)phidiffU[ich][k][m][ix][l]=NAN; }   
            ln++;
         }
         
         for(int m=0;m<NM;m++) for(int ix=0;ix<NX;ix++)for(int ich=0;ich<Nch;ich++) for(int l=0;l<6;l++) phidiffU[ich][k][m][ix][l]/=log(10);
         fclose(F);
         for(int m=0;m<NM;m++) for(int ix=0;ix<NX;ix++) if(!isfinite(phidiffU[0][k][m][ix][0]))
         { 
           if(ix>0 && ix<NX-1 && isfinite(phidiffU[0][k][m][ix-1][0]) && isfinite(phidiffU[0][k][m][ix+1][0]))  for(int ich=0;ich<Nch;ich++) for(int l=0;l<6;l++) phidiffU[ich][k][m][ix][l] = 0.5*(phidiffU[ich][k][m][ix-1][l]+phidiffU[ich][k][m][ix+1][l]);
         }
         for(int m=0;m<NM;m++) for(int ix=0;ix<NX;ix++) if(!isfinite(phidiffU[0][k][m][ix][0])) for(int ich=0;ich<Nch;ich++) for(int l=0;l<6;l++) phidiffU[ich][k][m][ix][l] = phidiffU[ich][k][m][ix-1][l];
            
      }
      free(buff);
      init=1;
   } 


//     [ee]  [mumu] [tautau]  [uu]  [dd]  [ss]  [cc]  [bb]  [tt] [gaga]  [zz]  [ww]   [gg]  [hh]
//      0     1       2         3    4      5     6    7     8     9      10    11     12    13

  int ch=-1;
  switch(pdgN) 
  { case 1  : ch=4 ; break;
    case 2  : ch=3 ; break;
    case 3  : ch=5 ; break;
    case 4  : ch=6 ; break;
    case 5  : ch=7 ; break;
    case 6  : ch=8 ; break;
    case 11 : ch=0 ; break;
    case 13 : ch=1 ; break;
    case 15 : ch=2 ; break;
    case 21 : ch=12; break;
    case 22 : ch=9 ; break;
    case 23 : ch=10; break;
    case 24 : ch=11; break;
    case 25 : ch=13; break;
  }
   
  if(ch<0) return 2;
  int m;
  for(m=0;m<NM && Mass>dmMass[m];m++) continue;
  m--;
  double stab[NX];
  int shift;
  if(spectUncert>0) shift=0; else shift=1;  
  int key[6]={0,0,0,0,0,0};
  if(DHad)   key[0+shift]=1;
  if(DScale) key[2+shift]=1;
  if(DcNS)   key[4+shift]=1; 
  
  if(m==NM-1) for(int ix=0;ix<NX;ix++) 
  { stab[ix]=0; for(int l=0;l<6;l++) if(key[l]) stab[ix]+=pow(phidiffU[ch][outN][m][ix][l],2);
    stab[ix]=sqrt(stab[ix]);
  } 
  else  
  {
//     double a=(Mass-dmMass[m])/(dmMass[m+1]-dmMass[m]);
     double a=(log(Mass)-log(dmMass[m]))/(log(dmMass[m+1])-log(dmMass[m]));
     for(int ix=0;ix<NX;ix++)
     {
        double s1=0,s2=0;
        for(int l=0;l<6;l++) if(key[l]) { s1+=pow(phidiffU[ch][outN][m][ix][l],2); s2+=pow(phidiffU[ch][outN][m+1][ix][l],2);}
        stab[ix]=(1-a)*sqrt(s1) +a* sqrt(s2);
//        printf("A:x=%E stab[%d]=%E a=%E s1=%E s2=%E \n",x[ix],ix,stab[ix],a,s1,s2);
     }      
  }

  for(int i=1;i<NZ;i++) { double y=exp(Zi(i)); 
  if(y<x[0])tab[i]=0; else  tab[i]=polint1(y, NX, x, stab);}
 
  return 0;
}



#undef Nch  // 14
#undef NM   // 60
#undef NX   // 180   


int basicSpectra(double Mass, int pdgN, int outN, double * tab)
{  int err;
   pdgN=abs(pdgN); 
   switch(SpectraFlag)
   { case -1: err= basicSpectraS_(Mass,pdgN,outN,tab);   break;
     case 0:  err= basicSpectraS(Mass,pdgN,outN,tab);    break;
     case 1:  err= basicSpectraA(Mass,pdgN,outN,tab);    break;
     case 2:  err= basicSpectraPPPC(Mass,pdgN,outN,tab); break;  
     case 3:  err= basicSpectraCosmiXs(Mass,pdgN,outN,tab); break;
     default: err=4; tab[0]=Mass; for(int i=1;i<NZ;i++) tab[i]=0; break;
   }
   if(err) return err;
//printf("basicSpectra spectUncert=%d \n",spectUncert);
   if(spectUncert && (DHad||DScale||DcNS) && outN<3)
   {  
     double dtab[NZ];
     err=spectraUncertainty(Mass, pdgN, outN, dtab);
     if(!err)
     {
       if(spectUncert>0) for(int i=1;i<NZ;i++) { tab[i]+=dtab[i]; } 
                   else  for(int i=1;i<NZ;i++) { tab[i]-=dtab[i]; if(tab[i]<0) tab[i]=0;}
     }              
   }
   return 0;
}



double  spectrInfo(double Emin,double*tab,double*Etot)
{
  if(Etot) *Etot=0;
  if(Emin>=tab[0]) return 0;  else 
  { int i1,i2;
    double Xmin=Emin/tab[0],zmin,zmax=0;
    if(Xmin<1.22E-7) Xmin=1.22E-7;
    zmin=log(Xmin); 
    for(i1=Iz(zmin); i1>1 && tab[i1]==0;i1--) continue;
    if(i1<NZ-1) i1++;
    if(zmin<Zi(i1)) zmin=Zi(i1)+1E-6;

    
    for(i2=1; tab[i2]==0 && i2<NZ-1 ;i2++ );
    if(i2>1) i2--;
    if(zmax>Zi(i2)) zmax=Zi(i2)-1E-6;

    if(zmax<zmin) return 0;    
  
    if(Etot)*Etot=tab[0]*simpson_arg(zInterpE,tab, zmin, zmax,1.E-4,NULL);       
    return simpson_arg(zInterpVoid,tab, zmin, zmax,1.E-4,NULL);
  }  
}


double spectrInt(double Emin,double Emax, double * tab)
{ 
  double M=tab[0], zmin,zmax;
  int i1,i2;

  if(Emin<M*exp(Zi(NZ-1))) zmin=Zi(NZ-1); else if( Emin>=M) zmin=0; else zmin=log(Emin/M);
  if(Emax<M*exp(Zi(NZ-1))) zmax=Zi(NZ-1); else if( Emax>=M) zmax=0; else zmax=log(Emax/M);
  
  if(zmin>=zmax) return 0;
  
  for(i1=Iz(zmin) ;i1>1 && tab[i1]==0;i1--) continue;
  if(i1<NZ-1) i1++;
  if(zmin<Zi(i1)) zmin=Zi(i1)+1E-6;
 
  i2=Iz(zmax)+1; if(i2>NZ-1) i2=NZ-1;
  for( ;i2<NZ-1 && tab[i2]==0;i2--) continue;
  if(i2<2) i2--;
  if(zmax>Zi(i2)) zmax=Zi(i2)-1E-6;
  
  return simpson_arg(zInterpVoid,tab, zmin, zmax,1.E-4,NULL);
}

void  spectrMult( double *spect, double(*func)(double))
{ 
  int i; 
  double M=spect[0];
  for(i=1;i<NZ;i++)
  { double E=M*exp(Zi(i));
    spect[i]*=func(E);
  }  
}


void boost_old(double Y, double M0, double mx, double*tab)
{ 
  if(Y<0.01) return; 

  double chY=cosh(Y), shY=sinh(Y);
  int k,l,k0;
  double tab_out[NZ], tab_in[NZ];
  
  tab_in[0]=tab[0];
  for(int i=1;i<NZ;i++)
  { double e=tab[0]*exp(Zi(i));
    tab_in[i]=tab[i]/(sqrt(e*(e+2*mx)));
  } 
 
  for(k0=1;k0<NZ;k0++) if(tab[k0]) break;
  if(k0>1)k0--;
  double emax=tab[0]*exp(Zi(k0))*(1-1E-5); // integrand(emax)!=0
    
  double e=tab[0]*exp(Zi(k0)) +mx, p=sqrt(e*e-mx*mx), M=e*chY+p*shY-mx;
  if(M0<M) M0=M;     
 
  int kmin=NZ-1;
  for(; tab[kmin]==0 && kmin>0; kmin--) continue;
//printf("kmin=%d, x=%E\n",kmin,exp(Zi(kmin)));
  if(kmin==0) { tab[0]=M0;  return;}
  if(kmin<NZ-1) kmin++;  // tab[kmin]==0, tab[kmin+1]!=0;
  double emin=tab[0]*exp(Zi(kmin))*(1+1E-5);  // F(emin) != 0 
   
  for(l=1;l<NZ;l++)
  { double e=M0*exp(Zi(l)),e1,e2;
    if(mx==0) { e1=e*exp(-Y); e2=e*exp(Y);}  
    else 
    {
      if(e>mx) 
      {
        double YY=acosh(1+e/mx);
        e1=mx*(cosh(Y-YY)-1);
        e2=mx*(cosh(Y+YY)-1);
//printf("Y =%E YY=%E  e1=%E e2=%E\n", Y,YY,e1,e2);        
      }else 
      {
        double p=sqrt(e*(e+2*mx)); 
        e1=chY*(e+mx)-shY*p-mx;
        e2=chY*(e+mx)+shY*p-mx;
      }
    }
    if(e1>=tab[0]) {tab_out[l]=0; continue;}
    if(e2>emax) e2=emax;
    if(e2<=emin) { for(;l<NZ;l++) tab_out[l]=0; break;}
    if(e1<emin) e1=emin;
    int err=0,err_=0;
    if (e1>=e2) tab_out[l]=0; else tab_out[l]=e*simpson_arg(zInterpVoid,tab_in, log(e1/tab[0]),log(e2/tab[0]),1.E-3,&err_)/2/shY; 
  }
  
  for(l=1;l<NZ;l++) tab[l]=tab_out[l];
  tab[0]=M0;

}

void (*boost) (double Y, double M0, double mx, double*tab)=boost_old;


void boost_new(double Y, double M0, double mx, double*tab)
{ 

  double chY=cosh(Y), shY=sinh(Y);
  double e=tab[0]+mx, p=sqrt(e*e-mx*mx), M=e*chY+p*shY-mx;
  if(M0<M) M0=M;     

  double tab_out[NZ];  
  for(int i=1;i<NZ;i++) tab_out[i]=0;
        
  for(int i=1;i<NZ;i++) if(tab[i])
  { double x=exp(Zi(i));
    double v= (i==1)? 1-exp(Zi(2)) : exp(Zi(i-1))-exp(Zi(i+1));
    v*= tab[i]/x/2;
    e=tab[0]*x+mx; p=sqrt(e*e-mx*mx); 
    double x1=(e*chY+p*shY-mx)/M0, x2=(e*chY-p*shY-mx)/M0;
    int j1=Iz(log(x1))+1,j2=Iz(log(x2));
    double dx=exp(Zi(j1))-exp(Zi(j2))+0.5*(exp(Zi(j2))-exp(Zi(j2+1)));
    if(j1>1) dx+=0.5*(exp(Zi(j1-1))-exp(Zi(j1))); 
    v/=dx;
//    v/=(x1-x2);
//    printf("i=%d i1=%d i2=%d v=%E\n",i,j1,j2,v);
    if(j2>NZ-1) j2=NZ-1;
    for(int j=j1;j<=j2;j++) tab_out[j]+=v; 
  }
  for(int i=1;i<NZ;i++) if(tab_out[i]) tab_out[i]*=exp(Zi(i));
  tab[0]=M0; for(int i=1;i<NZ;i++) tab[i]=tab_out[i];
}


void addSpectrum_new(double *sp1, double * sp2) // adds sp2 to sp1. 
{
   if(sp1[0]==sp2[0]) { for(int i=1;i<NZ;i++) sp1[i]+=sp2[i]; return;}

   if(sp1[0]>sp2[0])
   { 
     for(int i2=1;i2<NZ;i2++) if(sp2[i2]!=0)
     {
//  sp2 grid 
        double x2=exp(Zi(i2));
        double v2= (i2>1)?    exp(Zi(i2-1)) -exp(Zi(i2+1)): exp(Zi(i2)) -exp(Zi(i2+1));
        v2*=sp2[i2]/x2;   // contrubution to total number of particles.
// sp1 grid
        double x1=x2*sp2[0]/sp1[0];   
        int    i1=Iz(log(x1))+1;
        int    i0=i1-1;
        if(i0>NZ-1) return;
        double x_0=exp(Zi(i0)), x_1=exp(Zi(i1)),x_2=exp(Zi(i1+1)); 
        double v0=(i0>1)? exp(Zi(i0-1))-x_1: x_0-x_1; 
        double v1=x_0-x_2;
 
        double c1=(x_0-x1 )/(x_0-x_1);

        sp1[i0]+=v2/v0*x_0*(1-c1);
        if(i1<=NZ-1) sp1[i1]+=v2/v1*x_1*c1;
     }       
   } else 
   {  double sp1_[NZ],sp2_[NZ];
      for(int i=0;i<NZ;i++) sp2_[i]=sp2[i];
      addSpectrum(sp2_, sp1);
      for(int i=0;i<NZ;i++) sp1[i]=sp2_[i]; 
   }
}


void addSpectrum_old(double *Spect, double * toAdd)
{
  double m1=Spect[0];
  double m2=toAdd[0];
  double buff[NZ];
  int i;
  
  if(fabs(m1-m2)<5E-3*(fabs(m1)+fabs(m2))) { for(int i=1; i<NZ; i++) Spect[i]+=toAdd[i]; return; }
  

  if(m1>m2) for(i=NZ-1;i>0;i--) 
  { 
     double E= m1*exp(Zi(i));
     if(E>m2) return; 
     Spect[i]+=  SpectdNdE(E,toAdd)*E;  
  } else  
  { for(i=0;i<NZ;i++) buff[i]=Spect[i];
    for(i=0;i<NZ;i++) Spect[i]=toAdd[i];
    for(i=NZ-1;i>0;i--) 
    {  
       double E= m2*exp(Zi(i)); 
       if(E>m1) return;
       Spect[i]+=  SpectdNdE(E,buff)*E;
    } 
  }
} 


void (*addSpectrum)(double *Spect, double * toAdd)=addSpectrum_old;


double FSRdNdE(double E, double p,double m, double q, int spin2,int med )  // https://arxiv.org/pdf/1907.11846.pdf Eq.4.8 - 4.11
{
  double M=sqrt(p*p+m*m);
  double mu2=m*m/(M*M)/4;
  double alpha=1./137.;
  double x=E/M;
  
  if(x>= 1-4*mu2) return 0; 
   
  double sq=sqrt(1-4*mu2/(1-x));
  double lg= (4*mu2/(1-x)>1E-5) ?  log((1+sq)/(1-sq)) : log((1+sq)/(2*mu2/(1-x)));
  double res;
  
  if(med==0) 
  {
    if(spin2&1)  res=1/(1-4*mu2)*( (2*(1-x-6*mu2)+pow(x+4*mu2,2))*lg -2*(1-4*mu2)*(1-x)*sq);    
    else         res=2*((1-x-2*mu2)*lg -(1-x)*sq);
  } else 
  {
    if(spin2&1)  res=1/(1+2*mu2)*((1+pow(1-x,2)-4*mu2*(x+2*mu2))*lg -(1+pow(1-x,2)+4*mu2*(1-x))*sq);
    else         res=2/(1-4*mu2)*((1-x-2*mu2)*(1-4*mu2)*lg - ((1-x)*(1-4*mu2)-x*x)*sq);   
  } 
//printf(" x=%E lg=%E M=%E sq=%E \n",x,lg,M,sq);  

  return  q*q*alpha*res/(E*M_PI*sqrt(1-4*mu2));
}
